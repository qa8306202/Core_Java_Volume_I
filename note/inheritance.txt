1. 类、超类和子类
1.1.定义子类
继承类Employee 类来定义Manager类的格式，关键字extends表示继承。
public class Manage extends Employee
{
    private double bonus;

    public void setBonus(double bonus)
    {
        this.bonus = bonus
    }
}
1.1.1. Java和C++定义继承类的方法十分相似，Java使用extends而C++使用冒号（：），另外java中都是共有继承，但是C++中有私有、保护继承。
1.1.2. 这里Employee 是父类parent class（超类super class、基类base class），Manage是子类subclass（派生类derived class）。注意，子类比超类拥有更加丰富的功能。
1.1.3. 在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处，因此在设计类的时候，应该讲通用的方法放在超类中，而将具有特殊用途的方法放在子类中。

1.2 覆盖方法
    超类中的有些方法对子类并不一定适用。比如Manager 类中的getSalary方法应该返回薪水和奖金的总和。为此，需要一个新的方法来覆盖（override）超类中的方法。
    public double getSalary()
    {
        return salary + bonus; // wont work
    }

    上面这个方法是么有办法工作的，虽然Manager对象都拥有一个名为salary的域，但在manager类的getSalary方法并不能直接地访问salary域。只有Employee类的方法才能够访问私有部分。如果Manager类的方法一定要访问私有域，就必须借助公有接口，Employee类中的公有方法getSalary正是这样的一个接口：

    public double getSalary（）
    {
        double baseSalary = getSalary(); // still wont work，this is a recurision.
        return baseSalary + bonus;
    }

    如果想要调用超类Employee 中的方法getSalary方法，而不是当前类的这个方法。为此，可以使用特定关键字super解决这个问题：
    public double getSalary（）
    {
        double baseSalary = super.getSalary(); // this is right
        return baseSalary + bonus;
    }

    关于super,在C++中则用::表示，即换成Employee::getSalary。super其实是指示编译器调用超类方法的特殊关键字，和this还是不同的。

1.3 子类构造器
    public Manager(String name, double salary, int year, int month, int day)
    {
        super(name, salary, year, month, day);  // this super is different from the beyond one, which means call superclass builder
        bonus = 0;
    }

1.4 继承层次
    由一个公共超类派生出来的所有类的集合被称为继承层次（inheritance hierarchy)。在继承层次中，从某个特定的类到其祖先的路径被称为继承链（inheritance chain）。

1.5 多态
    判断继承规则使用“is a” 规则。“is a”规则的另外一个表述法是置换法则。它表明程序中出现超类对象的任何地方都可以用子类对象置换。

        Employee e;
        e = new Employee(...); // Employee obj expected
        e = new Manager(...);  // Ok,Manager can be used as well

    Java中变量是多态的，一个Employee对象既可以引用一个Employee类对象，也可以引用一个Employee类的任何子类的对象。

        Manager boss = new Manager(...); // this is a subclass
        Employee[] staff = new Employee[3];  // this is a superclass array
        staff[0] = boss;  // this means superclass can reference subclass, but staff[0] cannt use subclass func

    另外在Java中，子类数组的引用可以转化成超类数组的引用，而不需要采用强制类型转换。但是在初始化的时候，必须使用子类初始化，否则会引发ArrayStoreException异常。
    另外，虽然两个数组都是引用同一个对象，但必须使用子类数组变量才能引用子类（特有）方法。

        Manager[] managers = new Manager[10];
        Employee[] staff = managers;
        // Exception in thread "main" java.lang.ArrayStoreException: com.chapter_5._1_inheritance.Employee
        // staff[0] = new Employee("Harry",50000,1980,12,15);
        staff[0] = new Manager("Harry",50000,1980,12,15);
        // staff[0].setBonus(500); // Employee dont find func setBonus(int)
        managers[0].setBonus(500);
        System.out.println(staff[0].getSalary());

1.6 理解方法调用
    假设要调用x.f(args),隐式参数x声明为类C的一个对象，下面是调用过程的详细描述：
        1）编译器查看对象的声明类型的方法名。假设调用x.f(param)，且隐式参数x声明为C类的对象。需要注意的是：可能存在多个名为f但参数类型不一样的方法，包括所有C类名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。
        2）编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为重载解析（overloading resolution）。Java中方法的签名是方法的名字和其参数列表。而返回类型只要具有兼容性即可，不必完全相同。这里有个术语：“协变返回类型covariant return”指的是子类中的成员函数的返回值类型不必严格等同于父类中被重写的成员函数的返回值类型如果子类覆盖的方法返回类型与基类不同。
        3）如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方法称为“静态绑定（static binding）”。相反是动态绑定
        4）当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。每次调用方法都要进行搜索，时间开销相当大，因此，虚拟机预先为每个类创建了一个方法表（method table），其中列出了所有方法的签名和实际调用的方法。
    举例，调用5_1_inheritance中e.getSalary()方法的解析过程：
        1）首先，虚拟机提取e的实际类型的方法表。既可能是Employee、Manager的方法表，也可能是Employee类的其他子类的方法表。
        2）虚拟机搜索定义getSalary签名的类。此时，虚拟机已经知道应该调用哪个方法。
        3）虚拟机调用方法。
    动态绑定有一个非常重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。假设增加一个新类Executive,并且变量e有可能引用这个类的对象，我们不需要对包含调用e.getSalary的代码进行重新编译。如果e恰好引用一个Executive类的UI小，就会自动地调用Executive.getSalary（）方法。

    注意：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性，特别是如果超类是public，子类一定要是public（不能是private）。

1.7 阻止继承：final类和方法
    如果一个类不想被继承，可以写为 public final class Executive extends Manager  ,另外域也可以被声明为final，对于final域来说，构造对象之后就不运行改变他们的值了。不过，如果一个类声明为final，只有其中你的方法自动地成为final 方法而不包括域。
    将方法或类声明为final主要目的是：确保它们不会在子类中改变语义。
    在C++中，如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程称为内联（inlining）。比如getName()将被替换为方法e.name域

1.8 强制类型转换
    进行类型转换的唯一原因是：在暂时忽视对象的实际类型后，使用对象的全部功能。但是编译器会检查是否可以做强制转换。即：
        1）只能在继承层次内进行类型转换。
        2）在将超类转换成子类之前，应该使用instanceof进行检查。
    但，一般情况下应该尽量少使用类型转换和instanceof运算符。

1.9 抽象类
    雇员和学生都属于class person中，假设我们添加一个getDescription方法，用来描述雇员和学生。那么person的getDescription则不需要实现，那么他就是一个抽象方法。一般，为了提高程序的清晰度，包含抽象方法的类本身必须声明为抽象类。
    public abstract class Person
    {
        ...
        public abstract String getDescription();
    }

    抽象类不能被实例化，因此建议在抽象类中不包含具体方法。尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中。
    虽然不能对抽象类实例化，但是可以定义一个抽象类的对象变量。
    Person p = new Student(...); // right
    Person p = new Persion(...); // wrong
    Person[] people = new Person[2]; // right, this is creating  obj （allocate a space）but not instancing it.

1.10 受保护访问
    假设需要将设计的类提供给其他程序员使用，而在这个类中国你设置了一些受保护域，由于其他程序员可以由这个类再派生出新类，并访问其中的受保护域。在这种情况下，如果需要对这个类的实现进行修改，就必须通知所有使用这个类的程序员。这违背了OOP提倡的数据封装原则。
    受保护的方法更具有实际意义。这种方法的一个最好的示例就是object类的clone方法。

    访问修饰符总结
    1）仅对本类可见————private
    2）对所有类可见————public
    3）对本包和所有子类可见————protected
    4）仅对本包可见————默认（不需要修饰符）

----------------------------------------------------------------------------------------------------------------------

2. Object:所有类的超类








